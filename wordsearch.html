<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>I Love You ü§ç</title>
  <style>
    body {
      font-family: sans-serif;
      background: #fce4ec;
      padding: 20px;
      text-align: center;
    }
    html, body {
      touch-action: manipulation;
      -webkit-user-select: none;
      user-select: none;
    }

    h1 { color: #ad1457; }
    #puzzle { display: inline-block; margin: 20px auto; user-select: none; touch-action: pan-x pan-y; }
    .row { display: flex; }
    .cell {
      width: 30px;
      height: 30px;
      border: 1px solid #ccc;
      font-size: 18px;
      line-height: 30px;
      text-transform: uppercase;
      cursor: pointer;
    }
    .found { background-color: #c8e6c9; color: #2e7d32; }
    .selected { background-color: #ffe082; }
    #wordList {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
      max-width: 220px;
      margin: 20px auto;
      padding: 0;
      list-style: none;
      justify-content: center;
    }
    #wordList li {
      background: #f8bbd0;
      padding: 8px 12px;
      border-radius: 5px;
      text-align: center;
    }
    #wordList .foundWord {
      background: #c8e6c9;
      text-decoration: line-through;
    }
    button {
      margin: 10px 8px;
      padding: 8px 20px;
      border: none;
      background: #f06292;
      color: white;
      border-radius: 5px;
      cursor: pointer;
    }
    @media (max-width: 600px) {
      .cell {
        width: 22px;
        height: 22px;
        font-size: 12px;
        line-height: 22px;
      }
      #wordList {
        grid-template-columns: repeat(2, 1fr);
        max-width: 220px;
      }
    }
  </style>
</head>
<body>
  <h1>Michelle's Word Search ü§ç</h1>
  <p>Tap and drag across the words to find them... oh and it‚Äôll save your progress bby ü§ç</p>
  <p>Words are vertical and horizontal, reversed too but never diagonal heh</p>
  <div id="puzzle"></div>
  <ul id="wordList"></ul>
  <button onclick="resetGrid()">Reset Grid (Shuffle)</button>
  <button onclick="revealAll()">Reveal All</button>

  <script>
    const allWords = [
      "Slytherin", "Draco", "Wand", "Hogwarts", "House", "Snake", "Green",
      "Benito", "Latin", "YHLQMDLG", "Reggaeton", "Beach", "Sunset", "Waves",
      "Sand", "Ocean", "Chocolate", "Strawberry", "Peonies", "Pink",
      "Romance", "Cat", "Whiskers", "Paws", "Meow", "Love", "Listing",
      "Realtor", "Commission", "Mortgage", "Appraisal", "Contract",
      "Buyer", "Seller", "Gryffindor", "Hufflepuff", "Ravenclaw", "Broomstick",
      "Magic", "Soulmate", "Island", "Kitten", "Perreo", "Amor", "TeAmoMichelle", "Rayados"
    ];

    const gridSize = 14;
    const maxWords = 10;
    const directions = [
      { x: 1, y: 0 }, { x: -1, y: 0 },
      { x: 0, y: 1 }, { x: 0, y: -1 }
    ];

    let grid = [];
    let words = [];
    let wordCoords = {};
    let foundCoords = new Set(JSON.parse(localStorage.getItem("foundCoords") || "[]"));
    let foundWordList = new Set(JSON.parse(localStorage.getItem("foundWords") || "[]"));

    function shuffle(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
      return array;
    }

    function createEmptyGrid() {
      return Array.from({ length: gridSize }, () => Array(gridSize).fill(""));
    }

    function canPlace(word, r, c, dir, gridRef) {
      for (let i = 0; i < word.length; i++) {
        const nr = r + i * dir.y;
        const nc = c + i * dir.x;
        if (nr < 0 || nr >= gridSize || nc < 0 || nc >= gridSize) return false;
        if (gridRef[nr][nc] && gridRef[nr][nc] !== word[i]) return false;
      }
      return true;
    }

    function placeWordsIntoGrid() {
      const tempGrid = createEmptyGrid();
      wordCoords = {};
      const lastWords = JSON.parse(localStorage.getItem("previousWords") || "[]");
      let pool = allWords.filter(w => !lastWords.includes(w));
      if (pool.length < maxWords) pool = allWords;
      const selected = shuffle(pool).slice(0, maxWords);
      const placed = [];

      for (let word of selected) {
        const options = [word.toUpperCase(), word.toUpperCase().split("").reverse().join("")];
        let placedSuccessfully = false;

        for (let opt of options) {
          for (let tries = 0; tries < 100 && !placedSuccessfully; tries++) {
            const dir = directions[Math.floor(Math.random() * directions.length)];
            const r = Math.floor(Math.random() * gridSize);
            const c = Math.floor(Math.random() * gridSize);
            if (canPlace(opt, r, c, dir, tempGrid)) {
              const coords = [];
              for (let i = 0; i < opt.length; i++) {
                const nr = r + i * dir.y;
                const nc = c + i * dir.x;
                tempGrid[nr][nc] = opt[i];
                coords.push(`${nr}-${nc}`);
              }
              wordCoords[opt] = coords;
              placedSuccessfully = true;
              placed.push(word);
              break;
            }
          }
        }
      }

      words = placed;
      localStorage.setItem("previousWords", JSON.stringify(placed));

      const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
      for (let r = 0; r < gridSize; r++) {
        for (let c = 0; c < gridSize; c++) {
          if (!tempGrid[r][c]) {
            tempGrid[r][c] = chars[Math.floor(Math.random() * chars.length)];
          }
        }
      }

      return tempGrid;
    }

    function renderGrid() {
      const puzzle = document.getElementById("puzzle");
      puzzle.innerHTML = "";
      for (let r = 0; r < gridSize; r++) {
        const rowDiv = document.createElement("div");
        rowDiv.classList.add("row");
        for (let c = 0; c < gridSize; c++) {
          const cell = document.createElement("div");
          cell.classList.add("cell");
          cell.dataset.row = r;
          cell.dataset.col = c;
          cell.textContent = grid[r][c];
          if (foundCoords.has(`${r}-${c}`)) {
            cell.classList.add("found");
          }
          rowDiv.appendChild(cell);
        }
        puzzle.appendChild(rowDiv);
      }
    }

    function renderWords() {
      const ul = document.getElementById("wordList");
      ul.innerHTML = "";
      for (let word of words) {
        const li = document.createElement("li");
        li.textContent = word;
        const up = word.toUpperCase();
        const rev = up.split("").reverse().join("");
        if (foundWordList.has(up) || foundWordList.has(rev)) {
          li.classList.add("foundWord");
        }
        ul.appendChild(li);
      }
    }

    function saveProgress() {
      localStorage.setItem("foundCoords", JSON.stringify([...foundCoords]));
      localStorage.setItem("foundWords", JSON.stringify([...foundWordList]));
      localStorage.setItem("savedGrid", JSON.stringify(grid));
      localStorage.setItem("placedWords", JSON.stringify(words));
      localStorage.setItem("wordCoords", JSON.stringify(wordCoords));
    }

    function resetGrid() {
      foundCoords = new Set();
      foundWordList = new Set();
      grid = placeWordsIntoGrid();
      saveProgress();
      renderGrid();
      renderWords();
    }

    function revealAll() {
      const coordsMap = JSON.parse(localStorage.getItem("wordCoords") || "{}");
      for (let coordList of Object.values(coordsMap)) {
        for (let coord of coordList) {
          foundCoords.add(coord);
        }
      }
      for (let word of words) {
        foundWordList.add(word.toUpperCase());
        foundWordList.add(word.toUpperCase().split("").reverse().join(""));
      }
      saveProgress();
      renderGrid();
      renderWords();
    }

    let isMouseDown = false;
    let selected = [];

    document.addEventListener("mousedown", (e) => {
      if (e.target.classList.contains("cell")) {
        isMouseDown = true;
        selected = [e.target];
        e.target.classList.add("selected");
      }
    });

    document.addEventListener("mouseover", (e) => {
      if (isMouseDown && e.target.classList.contains("cell") && !selected.includes(e.target)) {
        selected.push(e.target);
        e.target.classList.add("selected");
      }
    });

    document.addEventListener("mouseup", () => {
      if (!selected.length) return;
      const guess = selected.map(el => el.textContent).join("");
      const reverse = guess.split("").reverse().join("");
      const upperWords = words.map(w => w.toUpperCase());

      if (upperWords.includes(guess) || upperWords.includes(reverse)) {
        selected.forEach(el => {
          el.classList.remove("selected");
          el.classList.add("found");
          foundCoords.add(`${el.dataset.row}-${el.dataset.col}`);
        });
        foundWordList.add(guess);
        foundWordList.add(reverse);
        saveProgress();
        renderWords();
      } else {
        selected.forEach(el => el.classList.remove("selected"));
      }
      selected = [];
      isMouseDown = false;
    });

    // Mobile touch interaction support
    document.addEventListener("touchstart", (e) => {
      const cell = e.target;
      if (cell.classList.contains("cell")) {
        isMouseDown = true;
        selected = [cell];
        cell.classList.add("selected");
      }
    });

    document.addEventListener("touchmove", (e) => {
      const touch = e.touches[0];
      const el = document.elementFromPoint(touch.clientX, touch.clientY);
      if (isMouseDown && el && el.classList.contains("cell") && !selected.includes(el)) {
        selected.push(el);
        el.classList.add("selected");
      }
      e.preventDefault(); // prevent screen scrolling
    }, { passive: false });

    document.addEventListener("touchend", () => {
      if (!selected.length) return;
      const guess = selected.map(el => el.textContent).join("");
      const reverse = guess.split("").reverse().join("");
      const upperWords = words.map(w => w.toUpperCase());

      if (upperWords.includes(guess) || upperWords.includes(reverse)) {
        selected.forEach(el => {
          el.classList.remove("selected");
          el.classList.add("found");
          foundCoords.add(`${el.dataset.row}-${el.dataset.col}`);
        });
        foundWordList.add(guess);
        foundWordList.add(reverse);
        saveProgress();
        renderWords();
      } else {
        selected.forEach(el => el.classList.remove("selected"));
      }
      selected = [];
      isMouseDown = false;
    });

    // Load from saved data or generate new
    const savedGrid = localStorage.getItem("savedGrid");
    const savedWords = localStorage.getItem("placedWords");
    const savedCoords = localStorage.getItem("wordCoords");

    if (savedGrid && savedWords && savedCoords) {
      grid = JSON.parse(savedGrid);
      words = JSON.parse(savedWords);
      wordCoords = JSON.parse(savedCoords);
    } else {
      grid = placeWordsIntoGrid();
      saveProgress();
    }

    renderGrid();
    renderWords();

    window.onload = () => {
  const puzzle = document.getElementById("puzzle");

  puzzle.addEventListener("touchstart", (e) => {
    const cell = e.target;
    if (cell.classList.contains("cell")) {
      isMouseDown = true;
      selected = [cell];
      cell.classList.add("selected");
      puzzle.dataset.touching = "true";
    }
  });

  puzzle.addEventListener("touchmove", (e) => {
    const touch = e.touches[0];
    const el = document.elementFromPoint(touch.clientX, touch.clientY);
    if (puzzle.dataset.touching === "true" && el && el.classList.contains("cell") && !selected.includes(el)) {
      selected.push(el);
      el.classList.add("selected");
      e.preventDefault(); // ‚úÖ This only prevents scrolling inside the puzzle
    }
  }, { passive: false });

  puzzle.addEventListener("touchend", () => {
    puzzle.dataset.touching = "false";
    if (!selected.length) return;
    const guess = selected.map(el => el.textContent).join("");
    const reverse = guess.split("").reverse().join("");
    const upperWords = words.map(w => w.toUpperCase());

    if (upperWords.includes(guess) || upperWords.includes(reverse)) {
      selected.forEach(el => {
        el.classList.remove("selected");
        el.classList.add("found");
        foundCoords.add(`${el.dataset.row}-${el.dataset.col}`);
      });
      foundWordList.add(guess);
      foundWordList.add(reverse);
      saveProgress();
      renderWords();
    } else {
      selected.forEach(el => el.classList.remove("selected"));
    }
    selected = [];
    isMouseDown = false;
  });
};


  </script>
</body>
</html>
